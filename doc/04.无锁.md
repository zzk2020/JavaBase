## 无锁

### 无锁类的原理详解

#### CAS（Compare And Swap）

> CAS算法的过程是这样：它包括3个参数CAS(V, E, N)，V表示要更新的变量，E表示预期值，N表示新值。仅当V值定于E值时，才会将V的值设为N，如果V值和E值不同，则说明已经有其它线程做了更新，则当前线程什么都不做。最后，CAS返回当前V的真实值。CAS操作时抱着乐观的态度进行的，它总是认为自己可以成功完成操作。当多个线程同时使用CAS操作一个变量时，只有一个会胜出，并成功更新，其余均会失败，失败的线程不会被挂起，仅是被告知失败，并且允许再次尝试，当然也允许失败的线程放弃操作。基于这样的原理，CAS操作即使没有锁，也可以发现其它线程对当前线程的干扰，并进行恰当的处理。

#### CPU指令

- 虽然CAS有多个步骤，但是在CPU层面是原子操作，一条CPU指令执行的

```java
cmpxchg
/*
accumulator = AL, AX or EAX, depending on whether a byte, word, or doubleword comparison is being performed
*/
if(accumulator == Destination) {
	ZF = 1;
	Destination = Source;
} else {
	ZF = 0;
	accumulator = Destination;
}
```

### 无锁类的使用

#### AtomicInteger

##### 概述

Number

##### 主要接口

```java
public final int get() // 取得当前值
public final void set(int var1) // 设置当前值
public final int getAndSet(int var1) // 设置新值，并返回旧值
public final boolean compareAndSet(int expect, int u) // 如果当前值为expect,则设置为u
public final int getAndIncrement() // 当前值加1，返回旧值
public final int getAndDecrement() // 当前值减1，返回旧值
public final int getAndAdd(int var1) // 当前值加var1，返回旧值
public final int incrementAndGet() // 当前值加1，返回新值
public final int decrementAndGet() // 当前值减1，返回新值
public final int addAndGet(int var1) // 当前值加var1，返回新值
```

##### 主要接口的实现

#### Unsafe

##### 概述

非安全的操作，比如：
根据偏移量设置值
park()
底层的CAS操作
非公开的API，在不同版本的JDK中，可能有较大差异

##### 主要接口

```java
// 获取给定对象偏移量上的int值
public native int getInt(Object o, long offset);
// 设置给定对象偏移量上的int值
public native int putInt(Object o, long offset， int x);
// 获得字段在对象中的偏移量
public native long objectFieldOffset(Field f);
// 获得给定对象的int值，使用volatile语义
public native void putIntVolatile(Object o, long offset);
// 设置给定对象的int值，使用volatile语义
public native void getIntVolatile(Object o, long offset, int x);
// 和putIntVolatile()一样，但是它要求被操作字段就是volatile类型的
public native void putOrderedInt(Object o, long offset, int x);
```

#### AtomicReference

##### 概述

对引用进行修改
是一个模板类，抽象化了数据类型

##### 主要接口

#### AtomicStampedReference

##### 概述

有唯一标识的引用

![image-20200607163614333](D:\env\idea-workspaces\JavaBase\doc\md-images\04.无锁\image-20200607163614333.png)

##### 主要接口

#### AtomicIntegerArray

##### 概述

##### 主要接口

```java
// 获得数组第i个下标的元素
public final int get(int i)
// 获得数组的长度
public final int length()
// 将数组第i个下标对应的值设置为newValue，并返回就值
public final int getAndSet(int i, int newValue)
// 进行CAS操作，如果第i个下标对应的值等于expect，则更新为update，设置成功返回true
public final boolean compareAndSet(int i, int expect, int update)
// 将数组第i个下标对应的值加1
public final int getAndIncrement(int i)
// 将数组第i个下标对应的值减1
public final int getAndDecrement(int i)
// 将数组第i个下标对应的值加delta(delta可以是负数)
public final int getAndAdd(int delta)
```

> Integer.numberOfLeadingZeros(4)

![image-20200607165013645](D:\env\idea-workspaces\JavaBase\doc\md-images\04.无锁\image-20200607165013645.png)

#### AtomicIntegerFieldUpdater

##### 概述

让普通变量也享受原子操作

##### 主要接口

```java
AtomicIntegerFieldUpdater.newUpdater()
incrementAndGet()
```

##### 小说明

1. Updater只能修改它可见范围内的变量，因为Updater使用反射得到的变量，如果变量不可见，就会出错。比如如果score申明为private，就是不可见d。
2. 为了确保变量被正确的读取，它必须是volatile类型的。如果我们原有代码中为申明这个类型，那么简单的申明一下就行，这不会引起什么问题。
3. 由于CAS操作会通过对象实例中的偏移量直接进行赋值，因此，它不支持static字段（Unsafe.objectFieldOffset()不支持静态变量）。

### 无锁算法详解

Vector
LockFreeVector