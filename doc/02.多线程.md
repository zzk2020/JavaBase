# 多线程
## 1.什么是线程
- 线程是进程内的可执行单元
- 进程上下文切换时非常重量级操作
## 2.线程的基本操作

![image-20200607115401394](D:\env\idea-workspaces\JavaBase\doc\md-images\多线程\image-20200607115401394.png)

### 新建线程
```java
Thread t1 = new Thread();
tl.start();// 开启新线程，在新线程中执行
```

```java
Thread t1 = new Thread();
tl.run(); // 不能开启线程，在当前调用线程执行
```

```java
// Thread.run()的实现
// target时Runnable接口
public void run() {
    if(target != null) {
        target.run();
    }
}
```


```java
// 重写run()方法
Thread t1 = new Thread() {
    @Override
    public void run() {
        System.out.println("Hello, I am t1.");
    }
};
tl.start();
```

```java
// 传一个target实例
Thread t1 = new Thread(new CreateThread());
tl.start();
```

### 终止线程
- Thread.stop()不推荐使用。它会释放所有monitor锁
> 记录1： ID=1, NAME=小明
> 记录2： ID=2, NAME=小王

![image-20200607120740840](D:\env\idea-workspaces\JavaBase\doc\md-images\多线程\image-20200607120740840.png)

### 中断线程
```java
public void Thread.interrupt() // 中断线程，设置中断标志位
public boolean Thread.isInterrupted() // 判断释放中断，查看中断标志位
public static boolean Thread.interrupted() // 判断释放中断，并清除中断标志位
```
```java
public void run() {
    while(true) {
        Thread.yield();
    }
}
// 针对上面这个实现来说，下面的代码是不起作用的
t1.interrupt();
```
```java
// 优雅的实现
public void run() {
    while(true) {
        if(Thread.currentThread().isInterrupted()) {
            System.out,println("Interrupt!")
            break;
        }
        Thread.yield();
    }
}
```
### public static native void sleep(long millis) throws InterruptedException

```java
// 优雅的实现
public void run() {
    while(true) {
        if(Thread.currentThread().isInterrupted()) {
            System.out,println("Interrupt!")
            break;
        }
        
        try {
            Thread.sleep(2000);
        } catch(InterruptedException e) {
            System.out.println("Interrupted When Sleep.");
            // 设置中断标志位，抛出异常后会清除中断标志位
            Thread.currentThread().interrupt();
        }
        
        Thread.yield();
    }
}
```

### 挂起（suspend）和继续执行（resume）线程
- suspend()不会释放锁
- 如果加锁发生在resume()之前，则死锁发生

![image-20200607122847276](D:\env\idea-workspaces\JavaBase\doc\md-images\多线程\image-20200607122847276.png)

> 住：jps命令
> jstack 线程ID

### 等待线程结束（join）和谦让（yield）
> yield() 释放当前占用的资源，让其它线程执行，但是后续自己还会抢占资源的

```java
public final void join() throws InterruptedException
public final synchronized void join(long millis) throws InterruptedException
```
```java
// join的本质
while(isAlive()) {
    wait(0);
}
// 线程执行完毕后，JVM会调用notifyAll()
```
> 不要在Thread实例上使用wait()和notify()方法

## 3.守护进程
- 在后台默默地完成一些系统性的服务，比如垃圾回收线程、JIT线程就可以理解为守护线程
- 当一个Java应用内，只有守护进程时，Java虚拟机就会自然退出
```java
Thread t = new DaemonThread();
t.setDaemon(true); // 设置为守护进程， 必须在start方法前调用
t.start();
```

## 4.线程优先级
```java
public final static int MIN_PRIORITY = 1;
public final static int NORM_PRIORITY = 5;
public final static int MAX_PRIORITY = 10;
```
```java
Thread high = new HightPriority();
Thread low = new LowPriority();
high.setPriority(Thread.MAX_PRIORITY);
low.setPriority(Thread.MIN_PRIORITY);
low.start();
high.start();
```
> 高优先级的线程更容易在竞争中获胜，概率问题

## 5.基本的线程同步操作
- synchronized
	- 指定加锁对象：对给定对象加锁，进入同步代码前要获得给定对象的锁。
	- 直接作用与实例方法：相当于对当前实例加锁，进入同步代码前要获得当前实例的锁。
	- 直接作用与静态方法：相当于对当前类加锁，进入同步代码前要获得当前类的锁。
- Object.wait()、Object.notify()
> 调用方法前要获取 Object monitor

![image-20200607130047436](D:\env\idea-workspaces\JavaBase\doc\md-images\多线程\image-20200607130047436.png)

> 唤醒当前对象的所有线程上

```java
public class AccountingSync implements Runnable {
	static AccountingSync instance = new AccountingSync();
	static int i = 0;
	
	@Override
	public void run() {
		for(int j=0; j<10000000; j++) {
			synchronized(instance) {
				i++;
			}
		}
	}
}
```