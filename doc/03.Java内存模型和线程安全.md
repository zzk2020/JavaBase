## Java内存模型和线程安全
### 原子性
- 原子性是指一个操作是不可中断的。即使是在多线程一起执行的时候，一个操作一旦开始，就不会被其它线程干扰。
> i++是原子操作吗？ 不是

### 有序性
- 在并发时，程序的执行可能就会出现乱序
```java
class OrderExample {
	int a = 0;
	boolean flag = false;
	public void writer() {
		a = 1;
		flag = true;
	}
	public void reader() {
		if(flag) {
			int i = a + 1;
		}
	}
}
```

![image-20200607150525838](D:\env\idea-workspaces\JavaBase\doc\md-images\多线程\image-20200607150525838.png)

> 多线程时，实际执行不一定时按照白那些顺序

- 一条指令的执行是可以分为很多步骤的
	- 取指 IF
	
	- 译码和取寄存器操作数 ID
	
	- 执行或者有效地址计算 EX
	
	- 存储器访问 MEM
	
	- 写回WB
	

![image-20200607151146235](D:\env\idea-workspaces\JavaBase\doc\md-images\多线程\image-20200607151146235.png)

![image-20200607151552000](D:\env\idea-workspaces\JavaBase\doc\md-images\多线程\image-20200607151552000.png)

![image-20200607151743630](D:\env\idea-workspaces\JavaBase\doc\md-images\多线程\image-20200607151743630.png)

![image-20200607151845858](D:\env\idea-workspaces\JavaBase\doc\md-images\多线程\image-20200607151845858.png)

### 可见性
- 可见性是指当一个线程修改了某一个共享变量的值，其他线程是否能够立即知道这个修改。
	- 编译器优化
	- 硬件优化（如写吸收，批操作）

![image-20200607152126701](D:\env\idea-workspaces\JavaBase\doc\md-images\多线程\image-20200607152126701.png)

- Java虚拟机层面的可见性
	- http://hushi55.github.io/2015/01/05/volatile-assembly

- -server模式运行上述代码，永远不会停止

![image-20200607153025112](D:\env\idea-workspaces\JavaBase\doc\md-images\多线程\image-20200607153025112.png)

![image-20200607153140834](D:\env\idea-workspaces\JavaBase\doc\md-images\多线程\image-20200607153140834.png)


### Happen-Before规则（先行发生）
- 程序顺序原则：一个线程内保证语义的穿行行
```java
a = 1;
b = a + 1;
```

- volatile规则：volatile变量的写，先发生于读，这保证了volatile变量的可见性
- 锁规则：解锁（unlock）必然发生在随后的加锁（lock）前
- 传递性：A先于B，B先于C，那么A必然先于C
- 线程的start()方法先于它的每一个动作
- 线程的所有操作先于线程的终结（Thread.join()）
- 线程的中断（interrupt()）先于被中断线程的代码
- 对象的构造函数执行结束先于finalize()方法


### 线程安全的概念
- 指某个函数、函数库在多线程中被调用时，能够正确地处理各个线程的局部变量，使程序功能正确完成。
> i++在多线程下访问的情况

![image-20200607154317930](D:\env\idea-workspaces\JavaBase\doc\md-images\多线程\image-20200607154317930.png)

```java
public class AccountingSync implements Runnable {
	static AccountingSync instance = new AccountingSync();
	static int i = 0;
	
	@Override
	public void run() {
		for(int j=0; j<10000000; j++) {
			synchronized(instance) {
				i++;
			}
		}
	}
}
```